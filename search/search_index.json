{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kapitan Generators What are Generators Kapitan generators are a powerful addon to Kapitan to simplify the management your configuration setup. Think of them like \"Universal Templates\" that you can use to quickly create configurations (for instance, Kubernetes resources) through a Domain-Specific configuration. For example, the configuration: parameters : components : nginx : image : nginx Instructs the \" Kubernetes Generator \" to create a Deployment kubernete resoures for nginx. The configuration can be extended to include Secrets, Config Maps, Services, env variables, ports and more. The same configuration can be used by a \" Documentation Generator \" to create a nginx.md file with a description of the configuration to be consumed as documentation.","title":"Home"},{"location":"#kapitan-generators","text":"","title":"Kapitan Generators"},{"location":"#what-are-generators","text":"Kapitan generators are a powerful addon to Kapitan to simplify the management your configuration setup. Think of them like \"Universal Templates\" that you can use to quickly create configurations (for instance, Kubernetes resources) through a Domain-Specific configuration. For example, the configuration: parameters : components : nginx : image : nginx Instructs the \" Kubernetes Generator \" to create a Deployment kubernete resoures for nginx. The configuration can be extended to include Secrets, Config Maps, Services, env variables, ports and more. The same configuration can be used by a \" Documentation Generator \" to create a nginx.md file with a description of the configuration to be consumed as documentation.","title":"What are Generators"},{"location":"kubernetes/","text":"Kubernetes Generator The Kubernetes generator allows to quickly generate Kubernetes manifests. Getting started Download the kapitan-reference repository git clone git@github.com:kapicorp/kapitan-reference.git kapitan-templates cd kapitan-templates Create a target file Create a new kapitan target file in any subdirectory of the inventory/targets folder. For this tutorial, we will assume the target file to be inventory/targets/demo.yml The target name is the name of the file without the extentions (e.g demo ). Initial content of inventory/targets/demo.yml classes : # boilerplate class to get you started - common EVERY CHANGE -> Compile your targets EVERY time you make a change, you will want to tell kapitan to compile your targets. kapitan will create a folder for each target under the compiled folder To compile only the demo target ./kapitan compile -t demo To compile all targets ./kapitan compile Create a deployment Let's start by creating a simple component, a deployment to be more precise. Note: Also see the StatefulSet and Jobs sections! We will use the jmalloc/echo-server for this demo. The generator is expecting components to be defined under the parameters.components path of the inventory. For instance, create a component echo-server , simply create the following section: classes : # boilerplate class to get you started - common parameters : components : echo-server : image : jmalloc/echo-server Run kapitan compile and check the output in the compiled/demo/manifests folder. Defining envs You can define env variables by nesting them under the env directive: parameters : components : echo-server : <other config> env : KAPITAN_ROCKS : 'YES! You can also use secretKeyRef and configMapKeyRef provided you have defined your secrets/configmaps below. parameters : components : echo-server : <other config> env : KAPITAN_SECRET : secretKeyRef : name : a_secret *OPTIONAL* key : 'kapitan_secret' NOTE that you do not need to specify the name directive, as the generator will attempt to work out where to get it from. Also fieldRef works as expected parameters : components : echo-server : <other config> env : NODE_NAME : fieldRef : fieldPath : spec.nodeName Defining ports You can define the ports your component uses by adding them under the ports directive: parameters : components : echo-server : <other config> ports : http : container_port : 8080 The above will produce the following effect: --- a/compiled/demo/manifests/echo-server-bundle.yml +++ b/compiled/demo/manifests/echo-server-bundle.yml @@ -38,6 +38,10 @@ spec: - image: jmalloc/echo-server imagePullPolicy: IfNotPresent name: echo-server + ports: + - containerPort: 8080 + name: http + protocol: TCP Liveness and Readiness checks You can also quickly add a readiness / liveness check: parameters : components : echo-server : <other config> healthcheck : readiness : type : http port : http path : /health/readiness timeout_seconds : 3 liveness : type : http port : http path : /health/liveness timeout_seconds : 3 which produces: --- a/compiled/demo/manifests/echo-server-bundle.yml +++ b/compiled/demo/manifests/echo-server-bundle.yml @@ -42,6 +42,15 @@ spec: - containerPort: 8080 name: http protocol: TCP + readinessProbe: + failureThreshold: 3 + httpGet: + path: /health/readiness + port: http + scheme: HTTP + periodSeconds: 10 + successThreshold: 1 + timeoutSeconds: 3 + livenessProbe: + failureThreshold: 3 + httpGet: + path: /health/liveness + port: http + scheme: HTTP + periodSeconds: 10 + successThreshold: 1 + timeoutSeconds: 3 Types tcp and command are also supported. Exposing a service If you want to expose the service, add the service directive with the desired service type , and define the service_port : parameters : components : echo-server : <other config> service : type : ClusterIP ports : http : service_port : 80 container_port : 8080 Note : if you want to prevent a port from being added to the service, omit the <service_port> directive Which will create a service manifest with the same name as the component, and will produce the following effect: --- a/compiled/demo/manifests/echo-server-bundle.yml +++ b/compiled/demo/manifests/echo-server-bundle.yml @@ -52,3 +52,21 @@ metadata: name: echo-server name: echo-server namespace: demo +--- +apiVersion: v1 +kind: Service +metadata: + labels: + app: echo-server + name: echo-server + namespace: demo +spec: + ports: + - name: http + port: 80 + protocol: TCP + targetPort: http + selector: + app: echo-server + sessionAffinity: None + type: LoadBalancer If you want, you can give the service a different name by using the service_name directive. The service specification uses the following directives: directive description service_name \\< string > defines the name for the service type \\< LoadBalancer | ClusterIP | NodePort > the kubernetes service type selector \\< dict > key : value dict of additional selectors for the service publish_not_ready_address \\< bool > set spec.publishNotReadyAddresses headless \\< bool > makes service headless expose_ports \\< list[strings] > list of component.ports to expose with this service session_affinity \\< ClientIP | None > sets spec.sessionAffinity Defining additional services Sometimes, like in the case of vault you might need to define more Services resources than just the main one. You can then define multiple services with the additional_services configuration. Each additional service respect the same options as the main service definition. service : service_name : vault-internal type : ClusterIP publish_not_ready_address : True headless : True additional_services : vault-active : type : ClusterIP publish_not_ready_address : True selectors : vault-active : \"true\" vault-standby : type : ClusterIP publish_not_ready_address : True selectors : vault-active : \"false\" Config Maps and Secrets Creating both secrets and config maps is very simple with Kapitan Generators, and the interface is very similar with minor differences between them. Simple config map config_maps : config : data : echo-service.conf : value : |- # A configuration file example: true A ConfigMap manifest was created. The name is taken from the component. cat compiled/demo/manifests/echo-server-config.yml apiVersion : v1 data : echo-service.conf : '# A configuration file example: true' kind : ConfigMap metadata : labels : name : echo-server name : echo-server namespace : demo Mounting a config map as a directory Note that in the previous example the config map is not mounted, because the mount directive is missing. config_maps : config : mount : /opt/echo-service data : echo-service.conf : value : |- # A configuration file example: true Simply adding the above configuration, will immediately configure the component to mount the config map we have just defined: + volumeMounts: + - mountPath: /opt/echo-service + name: config + readOnly: true restartPolicy: Always terminationGracePeriodSeconds: 30 + volumes: + - configMap: + defaultMode: 420 + name: echo-server + name: config Use Jinja templates as configurations A more advanced way to create the configuration file, is to use an external jinja file as source: config_maps : config : mount : /opt/echo-service data : echo-service.conf : template : \"components/echo-server/echo-server.conf.j2\" values : example : true with the file echo-server.conf.j2 being a jinja template file. As expected, we can inject any value from the inventory into the the file. Add external files to ConfigMaps You can also use the file and the directory directives to copy a single file or a full directory to your ConfigMaps or Secrets. config_maps : config : mount : /opt/echo-service data : example.txt : file : \"components/echo-server/example.txt\" Filtering files to mount We do not always expect to mount all files available in a config map. Sometimes in the config map we have a mix of files and other values destined to be consumed by environment variables instead. For instance, given the following setup, we can restrict the mount only to files defined in the items directive: config_maps : config : mount : /opt/echo-service items : - echo-service.conf data : echo-service.conf : template : \"components/echo-server/echo-server.conf.j2\" values : example : true simple_config : value : \"not mounted\" the diff shows that the generator makes use of the items directive in the manifest: --- a/compiled/demo/manifests/echo-server-config.yml +++ b/compiled/demo/manifests/echo-server-bundle.yml @@ -60,6 +60,9 @@ spec: volumes: - configMap: defaultMode: 420 + items: + - key: echo-service.conf + path: echo-service.conf name: echo-server Secrets: auto base64 encode Secrets use the same configuations as config maps, but are nested under the secrets key. In addition, secrets support automatic base64 encoding with the b64_encode directive: secrets : secret : data : encoded_secret : value : my_secret b64_encode : true cat compiled/demo/manifests/echo-server-secret.yml apiVersion : v1 data : encoded_secret : bXlfc2VjcmV0 # ENCODED my_secret kind : Secret metadata : labels : name : echo-server name : echo-server namespace : demo type : Opaque Note that, because in this example the mount directive is missing, the secret will not be mounted automatically. Please review the generic way of Kapitan to manage secrets at https://kapitan.dev/secrets/ and Secrets management with Kapitan In summary, remember that you can summon the power of Google KMS (once setup) and use kapitan secrets like this: secrets : secret : data : encoded_secret : value : my_secret b64_encode : true better_secret : value : ?{gkms:targets/${target_name}/password||randomstr|base64} which will generate an truly encrypted secret using Google KMS (other backends also available) Versioned ConfigMaps and Secrets The generator can automatically \"version\" you ConfigMap or Secrets so that the associated workload can automatically detect the change and handle it appropriately (rollout restart) In both secrets and config_maps, just define versioned: true (default: false ) config_maps : config : versioned : true mount : /opt/echo-service data : example.txt : file : \"components/echo-server/example.txt\" The generator will hash the content of the resource, and add it to the name of the rendered object: kind: ConfigMap metadata: labels: name: echo-server name: echo-server-01f3716a namespace: echo-server [cut] when the content of the object changes, the hash will be updated accordingly. PLEASE NOTE: kapitan is not responsible for garbage collecting unused secrets of config maps. Shared ConfigMaps and Secrets The generator can create shared Secrets and ConfigMaps. In secrets, you can define either string_data to get a StringData secret or data to get a data secret. parameters : generators : kubernetes : secrets : plain-plain-connection : string_data : CONNECTION : value : postgresql://?{plain:targets/${target_name}/shared-password-plain-as-plain-user||randomstr:35}:?{plain:targets/${target_name}/shared-password-plain-as-plain-pass||randomstr:35}/database Deployment You can define a Deployment by using the type directive to deployment (its also the default type) The deployment uses all (applicable) configurations available to the deployment type. Volume Mounts and Volumes PLEATE NOTE PV,PVCs are not yet created automatically Issue #68 Volume from StorageClass volume_mounts : datadir : mountPath : /var/lib/mysql volumes : datadir : spec : accessModes : [ \"ReadWriteOnce\" ] storageClassName : \"myStorageClass\" resources : requests : storage : 10Gi HostPath volume_mounts : datadir : mountPath : /var/lib/mysql volumes : datadir : hostPath : path : /mnt/mydisk/mysql type : DirectoryOrCreate DaemonSet You can define a DaemonSet by using the type directive to daemonset (its also the default type) The deployment uses all (applicable) configurations available to the daemonset type. StatefulSet You can define a StatefulSet by using the type directive to statefulset (that normally defaults to deployment ) The statefulset uses all (applicable) configurations available to the deployment type, but also includes. Volume Mounts and Volume Claims volume_mounts : datadir : mountPath : /var/lib/mysql volume_claims : datadir : spec : accessModes : [ \"ReadWriteOnce\" ] storageClassName : \"standard\" resources : requests : storage : 10Gi Jobs and CronJobs You can define a Job by using the type directive to job (that normally defaults to deployment ) You can define a CronJob by setting the schedule type to a valid value. parameters : components : postgres-backup : type : job schedule : \"0 */6 * * *\" image : moep1990/pgbackup:lates env : PGDATABASE : postgres PGHOST : postgres PGPASSWORD : postgres PGPORT : 5432 PGUSER : postgres Which will automatically generate the CronJob resource apiVersion : batch/v1beta1 kind : CronJob metadata : labels : name : postgres-backup name : postgres-backup spec : jobTemplate : spec : backoffLimit : 1 completions : 1 parallelism : 1 template : metadata : labels : app.kubernetes.io/managed-by : kapitan app.kubernetes.io/part-of : gitea name : postgres-backup spec : containers : - env : - name : PGDATABASE value : postgres - name : PGHOST value : postgres - name : PGPASSWORD value : postgres - name : PGPORT value : \"5432\" - name : PGUSER value : postgres image : moep1990/pgbackup:latest imagePullPolicy : Always name : postgres-backup restartPolicy : Never terminationGracePeriodSeconds : 30 schedule : 0 */6 * * * Additional containers (sidecars) You can instruct the generator to add one or more additional containers to your definition: parameters : components : echo-server : <other config> # Additional containers additional_containers : nginx : image : nginx ports : nginx : service_port : 80 You can access the same config_maps and secrets as the main container, but you can override mountpoints and subPaths For instance while this is defined in the outer \"main\" container scope, we can still mount the nginx config file: parameters : components : echo-server : <other config> # Additional containers additional_containers : nginx : image : nginx ports : nginx : service_port : 80 config_maps : config : mount : /etc/nginx/conf.d/nginx.conf subPath : nginx.conf <other config> config_maps : config : mount : /opt/echo-service/echo-service.conf subPath : echo-service.conf data : echo-service.conf : template : \"components/echo-server/echo-server.conf.j2\" values : example : true nginx.conf : value : | server { listen 80; server_name localhost; location / { proxy_pass http://localhost:8080/; } error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } Init Containers You can instruct the generator to create initContainers by using the init_containers directive: parameters : components : echo-server : <other config> # Init containers init_containers : busybox : image : busybox commands : - echo test Just like the additional_containers , tou can access the same config_maps and secrets as the main container, but you can override mountpoints and subPaths. Network Policies You can also generate Network Policies by simply adding them under the network_policies structure. # One or many network policies network_policies : default : pod_selector : name : echo-server ingress : - from : - podSelector : matchLabels : role : frontend ports : - protocol : TCP port : 6379 Which will automatically generate the NetworkPolicy resource apiVersion : networking.k8s.io/v1 kind : NetworkPolicy metadata : labels : name : echo-server name : echo-server spec : ingress : - from : - podSelector : matchLabels : role : frontend ports : - port : 6379 protocol : TCP podSelector : name : echo-server policyTypes : - Ingress - Egress Prometheus rules and Service Monitor resources Define PrometheusRules and ServiceMonitor alongside your application definitions. For a working example, have a look at tesoro_monitoring.yaml PrometheusRules Simply add your definitions: parameters : components : tesoro : prometheus_rules : rules : - alert : TesoroFailedRequests annotations : message : \"tesoro_requests_failed_total has increased above 0\" expr : sum by (job, namespace, service, env) (increase(tesoro_requests_failed_total[5m])) > 0 for : 1m labels : severity : warning - alert : KapitanRevealRequestFailures annotations : message : \"kapitan_reveal_requests_failed_total has increased above 0\" expr : sum by (job, namespace, service, env) (increase(kapitan_reveal_requests_failed_total[5m])) > 0 for : 1m labels : severity : warning to produce: apiVersion : monitoring.coreos.com/v1 kind : PrometheusRule metadata : labels : name : tesoro.rules name : tesoro.rules namespace : tesoro spec : groups : - name : tesoro.rules rules : - alert : TesoroFailedRequests annotations : message : tesoro_requests_failed_total has increased above 0 expr : sum by (job, namespace, service, env) (increase(tesoro_requests_failed_total[5m])) > 0 for : 1m labels : severity : warning - alert : KapitanRevealRequestFailures annotations : message : kapitan_reveal_requests_failed_total has increased above 0 expr : sum by (job, namespace, service, env) (increase(kapitan_reveal_requests_failed_total[5m])) > 0 for : 1m labels : severity : warning ServiceMonitor parameters : components : tesoro : service_monitors : endpoints : - interval : 15s path : / targetPort : 9095 produces the following resource apiVersion : monitoring.coreos.com/v1 kind : ServiceMonitor metadata : labels : name : tesoro-metrics name : tesoro-metrics namespace : tesoro spec : endpoints : - interval : 15s path : / targetPort : 9095 jobLabel : tesoro-metrics namespaceSelector : matchNames : - tesoro selector : matchLabels : name : tesoro Role, Role-Bindings and Cluster-Role, Cluster-Role-Bindings parameters : components : filebeat : # ServiceAccount service_account : enabled : true create : true # ROLE + Binding role : binding : subjects : - kind : ServiceAccount roleRef : apiGroup : rbac.authorization.k8s.io kind : Role rules : - apiGroups : - \"\" resources : - secrets verbs : - create - delete - apiGroups : - \"\" resources : - pods - pods/log verbs : - get - create - delete - list - watch - update produces the following resource --- apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : labels : name : filebeat name : filebeat namespace : filebeat rules : - apiGroups : - \"\" resources : - secrets verbs : - create - delete - apiGroups : - \"\" resources : - pods - pods/log verbs : - get - create - delete - list - watch - update --- apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : labels : name : filebeat name : filebeat namespace : filebeat roleRef : apiGroup : rbac.authorization.k8s.io kind : Role name : filebeat subjects : - kind : ServiceAccount name : filebeat --- apiVersion : v1 kind : ServiceAccount metadata : labels : name : filebeat name : filebeat namespace : filebeat PodSecurityPolicy The spec is relatively raw here, since its too diverse to be automated enough. Annotations and labels are merged from global and PSP ones. parameters : components : drone : pod_security_policy : annotations : xxx : yyy labels : yyy : zzz spec : privileged : false # Required to prevent escalations to root. allowPrivilegeEscalation : false # This is redundant with non-root + disallow privilege escalation, # but we can provide it for defense in depth. requiredDropCapabilities : - ALL # Allow core volume types. volumes : - \"configMap\" - \"emptyDir\" - \"projected\" - \"secret\" - \"downwardAPI\" - \"persistentVolumeClaim\" hostNetwork : false hostIPC : false hostPID : false runAsUser : rule : \"MustRunAsNonRoot\" seLinux : rule : \"RunAsAny\" supplementalGroups : rule : \"MustRunAs\" ranges : # Forbid adding the root group. - min : 1 max : 65535 fsGroup : rule : \"MustRunAs\" ranges : # Forbid adding the root group. - min : 1 max : 65535 readOnlyRootFilesystem : false produces the following resource --- apiVersion : policy/v1beta1 kind : PodSecurityPolicy metadata : annotations : manifests.kapicorp.com/generated : \"true\" xxx : yyy labels : app.kubernetes.io/component : go app.kubernetes.io/managed-by : kapitan app.kubernetes.io/part-of : drone app.kubernetes.io/version : \"1\" yyy : zzz name : drone namespace : drone spec : allowPrivilegeEscalation : false fsGroup : ranges : - max : 65535 min : 1 rule : MustRunAs hostIPC : false hostNetwork : false hostPID : false privileged : false readOnlyRootFilesystem : false requiredDropCapabilities : - ALL runAsUser : rule : MustRunAsNonRoot seLinux : rule : RunAsAny supplementalGroups : ranges : - max : 65535 min : 1 rule : MustRunAs volumes : - configMap - emptyDir - projected - secret - downwardAPI - persistentVolumeClaim Defining default values for multiple components Sometimes, when defining many components, you and up repeating many repeating configurations. With this generator, you can define defaults in 2 ways: Global Generator Defaults The global defaults can be used to set defaults for every component being generated. As you can see, some defaults are already set: generators : manifest : default_config : type : deployment annotations : \"manifests.kapicorp.com/generated\" : true You do not have to change that class directly, as long as you add to the same inventory structure for another class. For instance, when we enable the features.tesoro class, we can see that we are adding the following yaml fragment: generators : manifest : default_config : globals : secrets : labels : tesoro.kapicorp.com : enabled Which has the effect to add the tesoro.kapicorp.com: enabled label to every generated configMap resource. Application defaults You can also create application defaults, where an application is a class/profile that can be associated to multiple components. For instance, let's assume you have the following definition for an application class called microservices parameters : applications : microservices : component_defaults : replicas : 3 env : KAPITAN_APPLICATION : microservices Every component that belongs to that application class will receive the defaults for the application. To associate a component to an application, use the application directive. parameters : components : echo-server : application : microservices image : jmalloc/echo-server Compiling, kapitan will generate a deployment with image jmalloc/echo-server , 3 replicas, an annotation and an env variable. apiVersion : apps/v1 kind : Deployment metadata : annotations : manifests.kapicorp.com/generated : \"true\" labels : app : echo-server name : echo-server namespace : tutorial spec : replicas : 3 selector : matchLabels : app : echo-server strategy : rollingUpdate : maxSurge : 1 maxUnavailable : 1 type : RollingUpdate template : metadata : labels : app : echo-server spec : containers : - env : - name : KAPITAN_APPLICATION value : microservices image : jmalloc/echo-server imagePullPolicy : IfNotPresent name : echo-server restartPolicy : Always terminationGracePeriodSeconds : 30","title":"Kubernetes"},{"location":"kubernetes/#kubernetes-generator","text":"The Kubernetes generator allows to quickly generate Kubernetes manifests.","title":"Kubernetes Generator"},{"location":"kubernetes/#getting-started","text":"","title":"Getting started"},{"location":"kubernetes/#download-the-kapitan-reference-repository","text":"git clone git@github.com:kapicorp/kapitan-reference.git kapitan-templates cd kapitan-templates","title":"Download the kapitan-reference repository"},{"location":"kubernetes/#create-a-target-file","text":"Create a new kapitan target file in any subdirectory of the inventory/targets folder. For this tutorial, we will assume the target file to be inventory/targets/demo.yml The target name is the name of the file without the extentions (e.g demo ).","title":"Create a target file"},{"location":"kubernetes/#initial-content-of-inventorytargetsdemoyml","text":"classes : # boilerplate class to get you started - common","title":"Initial content of inventory/targets/demo.yml"},{"location":"kubernetes/#every-change-compile-your-targets","text":"EVERY time you make a change, you will want to tell kapitan to compile your targets. kapitan will create a folder for each target under the compiled folder","title":"EVERY CHANGE -&gt; Compile your targets"},{"location":"kubernetes/#to-compile-only-the-demo-target","text":"./kapitan compile -t demo","title":"To compile only the demo target"},{"location":"kubernetes/#to-compile-all-targets","text":"./kapitan compile","title":"To compile all targets"},{"location":"kubernetes/#create-a-deployment","text":"Let's start by creating a simple component, a deployment to be more precise. Note: Also see the StatefulSet and Jobs sections! We will use the jmalloc/echo-server for this demo. The generator is expecting components to be defined under the parameters.components path of the inventory. For instance, create a component echo-server , simply create the following section: classes : # boilerplate class to get you started - common parameters : components : echo-server : image : jmalloc/echo-server Run kapitan compile and check the output in the compiled/demo/manifests folder.","title":"Create a deployment"},{"location":"kubernetes/#defining-envs","text":"You can define env variables by nesting them under the env directive: parameters : components : echo-server : <other config> env : KAPITAN_ROCKS : 'YES! You can also use secretKeyRef and configMapKeyRef provided you have defined your secrets/configmaps below. parameters : components : echo-server : <other config> env : KAPITAN_SECRET : secretKeyRef : name : a_secret *OPTIONAL* key : 'kapitan_secret' NOTE that you do not need to specify the name directive, as the generator will attempt to work out where to get it from. Also fieldRef works as expected parameters : components : echo-server : <other config> env : NODE_NAME : fieldRef : fieldPath : spec.nodeName","title":"Defining envs"},{"location":"kubernetes/#defining-ports","text":"You can define the ports your component uses by adding them under the ports directive: parameters : components : echo-server : <other config> ports : http : container_port : 8080 The above will produce the following effect: --- a/compiled/demo/manifests/echo-server-bundle.yml +++ b/compiled/demo/manifests/echo-server-bundle.yml @@ -38,6 +38,10 @@ spec: - image: jmalloc/echo-server imagePullPolicy: IfNotPresent name: echo-server + ports: + - containerPort: 8080 + name: http + protocol: TCP","title":"Defining ports"},{"location":"kubernetes/#liveness-and-readiness-checks","text":"You can also quickly add a readiness / liveness check: parameters : components : echo-server : <other config> healthcheck : readiness : type : http port : http path : /health/readiness timeout_seconds : 3 liveness : type : http port : http path : /health/liveness timeout_seconds : 3 which produces: --- a/compiled/demo/manifests/echo-server-bundle.yml +++ b/compiled/demo/manifests/echo-server-bundle.yml @@ -42,6 +42,15 @@ spec: - containerPort: 8080 name: http protocol: TCP + readinessProbe: + failureThreshold: 3 + httpGet: + path: /health/readiness + port: http + scheme: HTTP + periodSeconds: 10 + successThreshold: 1 + timeoutSeconds: 3 + livenessProbe: + failureThreshold: 3 + httpGet: + path: /health/liveness + port: http + scheme: HTTP + periodSeconds: 10 + successThreshold: 1 + timeoutSeconds: 3 Types tcp and command are also supported.","title":"Liveness and Readiness checks"},{"location":"kubernetes/#exposing-a-service","text":"If you want to expose the service, add the service directive with the desired service type , and define the service_port : parameters : components : echo-server : <other config> service : type : ClusterIP ports : http : service_port : 80 container_port : 8080 Note : if you want to prevent a port from being added to the service, omit the <service_port> directive Which will create a service manifest with the same name as the component, and will produce the following effect: --- a/compiled/demo/manifests/echo-server-bundle.yml +++ b/compiled/demo/manifests/echo-server-bundle.yml @@ -52,3 +52,21 @@ metadata: name: echo-server name: echo-server namespace: demo +--- +apiVersion: v1 +kind: Service +metadata: + labels: + app: echo-server + name: echo-server + namespace: demo +spec: + ports: + - name: http + port: 80 + protocol: TCP + targetPort: http + selector: + app: echo-server + sessionAffinity: None + type: LoadBalancer If you want, you can give the service a different name by using the service_name directive. The service specification uses the following directives: directive description service_name \\< string > defines the name for the service type \\< LoadBalancer | ClusterIP | NodePort > the kubernetes service type selector \\< dict > key : value dict of additional selectors for the service publish_not_ready_address \\< bool > set spec.publishNotReadyAddresses headless \\< bool > makes service headless expose_ports \\< list[strings] > list of component.ports to expose with this service session_affinity \\< ClientIP | None > sets spec.sessionAffinity","title":"Exposing a service"},{"location":"kubernetes/#defining-additional-services","text":"Sometimes, like in the case of vault you might need to define more Services resources than just the main one. You can then define multiple services with the additional_services configuration. Each additional service respect the same options as the main service definition. service : service_name : vault-internal type : ClusterIP publish_not_ready_address : True headless : True additional_services : vault-active : type : ClusterIP publish_not_ready_address : True selectors : vault-active : \"true\" vault-standby : type : ClusterIP publish_not_ready_address : True selectors : vault-active : \"false\"","title":"Defining additional services"},{"location":"kubernetes/#config-maps-and-secrets","text":"Creating both secrets and config maps is very simple with Kapitan Generators, and the interface is very similar with minor differences between them.","title":"Config Maps and Secrets"},{"location":"kubernetes/#simple-config-map","text":"config_maps : config : data : echo-service.conf : value : |- # A configuration file example: true A ConfigMap manifest was created. The name is taken from the component. cat compiled/demo/manifests/echo-server-config.yml apiVersion : v1 data : echo-service.conf : '# A configuration file example: true' kind : ConfigMap metadata : labels : name : echo-server name : echo-server namespace : demo","title":"Simple config map"},{"location":"kubernetes/#mounting-a-config-map-as-a-directory","text":"Note that in the previous example the config map is not mounted, because the mount directive is missing. config_maps : config : mount : /opt/echo-service data : echo-service.conf : value : |- # A configuration file example: true Simply adding the above configuration, will immediately configure the component to mount the config map we have just defined: + volumeMounts: + - mountPath: /opt/echo-service + name: config + readOnly: true restartPolicy: Always terminationGracePeriodSeconds: 30 + volumes: + - configMap: + defaultMode: 420 + name: echo-server + name: config","title":"Mounting a config map as a directory"},{"location":"kubernetes/#use-jinja-templates-as-configurations","text":"A more advanced way to create the configuration file, is to use an external jinja file as source: config_maps : config : mount : /opt/echo-service data : echo-service.conf : template : \"components/echo-server/echo-server.conf.j2\" values : example : true with the file echo-server.conf.j2 being a jinja template file. As expected, we can inject any value from the inventory into the the file.","title":"Use Jinja templates as configurations"},{"location":"kubernetes/#add-external-files-to-configmaps","text":"You can also use the file and the directory directives to copy a single file or a full directory to your ConfigMaps or Secrets. config_maps : config : mount : /opt/echo-service data : example.txt : file : \"components/echo-server/example.txt\"","title":"Add external files to ConfigMaps"},{"location":"kubernetes/#filtering-files-to-mount","text":"We do not always expect to mount all files available in a config map. Sometimes in the config map we have a mix of files and other values destined to be consumed by environment variables instead. For instance, given the following setup, we can restrict the mount only to files defined in the items directive: config_maps : config : mount : /opt/echo-service items : - echo-service.conf data : echo-service.conf : template : \"components/echo-server/echo-server.conf.j2\" values : example : true simple_config : value : \"not mounted\" the diff shows that the generator makes use of the items directive in the manifest: --- a/compiled/demo/manifests/echo-server-config.yml +++ b/compiled/demo/manifests/echo-server-bundle.yml @@ -60,6 +60,9 @@ spec: volumes: - configMap: defaultMode: 420 + items: + - key: echo-service.conf + path: echo-service.conf name: echo-server","title":"Filtering files to mount"},{"location":"kubernetes/#secrets-auto-base64-encode","text":"Secrets use the same configuations as config maps, but are nested under the secrets key. In addition, secrets support automatic base64 encoding with the b64_encode directive: secrets : secret : data : encoded_secret : value : my_secret b64_encode : true cat compiled/demo/manifests/echo-server-secret.yml apiVersion : v1 data : encoded_secret : bXlfc2VjcmV0 # ENCODED my_secret kind : Secret metadata : labels : name : echo-server name : echo-server namespace : demo type : Opaque Note that, because in this example the mount directive is missing, the secret will not be mounted automatically. Please review the generic way of Kapitan to manage secrets at https://kapitan.dev/secrets/ and Secrets management with Kapitan In summary, remember that you can summon the power of Google KMS (once setup) and use kapitan secrets like this: secrets : secret : data : encoded_secret : value : my_secret b64_encode : true better_secret : value : ?{gkms:targets/${target_name}/password||randomstr|base64} which will generate an truly encrypted secret using Google KMS (other backends also available)","title":"Secrets: auto base64 encode"},{"location":"kubernetes/#versioned-configmaps-and-secrets","text":"The generator can automatically \"version\" you ConfigMap or Secrets so that the associated workload can automatically detect the change and handle it appropriately (rollout restart) In both secrets and config_maps, just define versioned: true (default: false ) config_maps : config : versioned : true mount : /opt/echo-service data : example.txt : file : \"components/echo-server/example.txt\" The generator will hash the content of the resource, and add it to the name of the rendered object: kind: ConfigMap metadata: labels: name: echo-server name: echo-server-01f3716a namespace: echo-server [cut] when the content of the object changes, the hash will be updated accordingly. PLEASE NOTE: kapitan is not responsible for garbage collecting unused secrets of config maps.","title":"Versioned ConfigMaps and Secrets"},{"location":"kubernetes/#shared-configmaps-and-secrets","text":"The generator can create shared Secrets and ConfigMaps. In secrets, you can define either string_data to get a StringData secret or data to get a data secret. parameters : generators : kubernetes : secrets : plain-plain-connection : string_data : CONNECTION : value : postgresql://?{plain:targets/${target_name}/shared-password-plain-as-plain-user||randomstr:35}:?{plain:targets/${target_name}/shared-password-plain-as-plain-pass||randomstr:35}/database","title":"Shared ConfigMaps and Secrets"},{"location":"kubernetes/#deployment","text":"You can define a Deployment by using the type directive to deployment (its also the default type) The deployment uses all (applicable) configurations available to the deployment type.","title":"Deployment"},{"location":"kubernetes/#volume-mounts-and-volumes","text":"PLEATE NOTE PV,PVCs are not yet created automatically Issue #68","title":"Volume Mounts and Volumes"},{"location":"kubernetes/#volume-from-storageclass","text":"volume_mounts : datadir : mountPath : /var/lib/mysql volumes : datadir : spec : accessModes : [ \"ReadWriteOnce\" ] storageClassName : \"myStorageClass\" resources : requests : storage : 10Gi","title":"Volume from StorageClass"},{"location":"kubernetes/#hostpath","text":"volume_mounts : datadir : mountPath : /var/lib/mysql volumes : datadir : hostPath : path : /mnt/mydisk/mysql type : DirectoryOrCreate","title":"HostPath"},{"location":"kubernetes/#daemonset","text":"You can define a DaemonSet by using the type directive to daemonset (its also the default type) The deployment uses all (applicable) configurations available to the daemonset type.","title":"DaemonSet"},{"location":"kubernetes/#statefulset","text":"You can define a StatefulSet by using the type directive to statefulset (that normally defaults to deployment ) The statefulset uses all (applicable) configurations available to the deployment type, but also includes.","title":"StatefulSet"},{"location":"kubernetes/#volume-mounts-and-volume-claims","text":"volume_mounts : datadir : mountPath : /var/lib/mysql volume_claims : datadir : spec : accessModes : [ \"ReadWriteOnce\" ] storageClassName : \"standard\" resources : requests : storage : 10Gi","title":"Volume Mounts and Volume Claims"},{"location":"kubernetes/#jobs-and-cronjobs","text":"You can define a Job by using the type directive to job (that normally defaults to deployment ) You can define a CronJob by setting the schedule type to a valid value. parameters : components : postgres-backup : type : job schedule : \"0 */6 * * *\" image : moep1990/pgbackup:lates env : PGDATABASE : postgres PGHOST : postgres PGPASSWORD : postgres PGPORT : 5432 PGUSER : postgres Which will automatically generate the CronJob resource apiVersion : batch/v1beta1 kind : CronJob metadata : labels : name : postgres-backup name : postgres-backup spec : jobTemplate : spec : backoffLimit : 1 completions : 1 parallelism : 1 template : metadata : labels : app.kubernetes.io/managed-by : kapitan app.kubernetes.io/part-of : gitea name : postgres-backup spec : containers : - env : - name : PGDATABASE value : postgres - name : PGHOST value : postgres - name : PGPASSWORD value : postgres - name : PGPORT value : \"5432\" - name : PGUSER value : postgres image : moep1990/pgbackup:latest imagePullPolicy : Always name : postgres-backup restartPolicy : Never terminationGracePeriodSeconds : 30 schedule : 0 */6 * * *","title":"Jobs and CronJobs"},{"location":"kubernetes/#additional-containers-sidecars","text":"You can instruct the generator to add one or more additional containers to your definition: parameters : components : echo-server : <other config> # Additional containers additional_containers : nginx : image : nginx ports : nginx : service_port : 80 You can access the same config_maps and secrets as the main container, but you can override mountpoints and subPaths For instance while this is defined in the outer \"main\" container scope, we can still mount the nginx config file: parameters : components : echo-server : <other config> # Additional containers additional_containers : nginx : image : nginx ports : nginx : service_port : 80 config_maps : config : mount : /etc/nginx/conf.d/nginx.conf subPath : nginx.conf <other config> config_maps : config : mount : /opt/echo-service/echo-service.conf subPath : echo-service.conf data : echo-service.conf : template : \"components/echo-server/echo-server.conf.j2\" values : example : true nginx.conf : value : | server { listen 80; server_name localhost; location / { proxy_pass http://localhost:8080/; } error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } }","title":"Additional containers (sidecars)"},{"location":"kubernetes/#init-containers","text":"You can instruct the generator to create initContainers by using the init_containers directive: parameters : components : echo-server : <other config> # Init containers init_containers : busybox : image : busybox commands : - echo test Just like the additional_containers , tou can access the same config_maps and secrets as the main container, but you can override mountpoints and subPaths.","title":"Init Containers"},{"location":"kubernetes/#network-policies","text":"You can also generate Network Policies by simply adding them under the network_policies structure. # One or many network policies network_policies : default : pod_selector : name : echo-server ingress : - from : - podSelector : matchLabels : role : frontend ports : - protocol : TCP port : 6379 Which will automatically generate the NetworkPolicy resource apiVersion : networking.k8s.io/v1 kind : NetworkPolicy metadata : labels : name : echo-server name : echo-server spec : ingress : - from : - podSelector : matchLabels : role : frontend ports : - port : 6379 protocol : TCP podSelector : name : echo-server policyTypes : - Ingress - Egress","title":"Network Policies"},{"location":"kubernetes/#prometheus-rules-and-service-monitor-resources","text":"Define PrometheusRules and ServiceMonitor alongside your application definitions. For a working example, have a look at tesoro_monitoring.yaml","title":"Prometheus rules and Service Monitor resources"},{"location":"kubernetes/#prometheusrules","text":"Simply add your definitions: parameters : components : tesoro : prometheus_rules : rules : - alert : TesoroFailedRequests annotations : message : \"tesoro_requests_failed_total has increased above 0\" expr : sum by (job, namespace, service, env) (increase(tesoro_requests_failed_total[5m])) > 0 for : 1m labels : severity : warning - alert : KapitanRevealRequestFailures annotations : message : \"kapitan_reveal_requests_failed_total has increased above 0\" expr : sum by (job, namespace, service, env) (increase(kapitan_reveal_requests_failed_total[5m])) > 0 for : 1m labels : severity : warning to produce: apiVersion : monitoring.coreos.com/v1 kind : PrometheusRule metadata : labels : name : tesoro.rules name : tesoro.rules namespace : tesoro spec : groups : - name : tesoro.rules rules : - alert : TesoroFailedRequests annotations : message : tesoro_requests_failed_total has increased above 0 expr : sum by (job, namespace, service, env) (increase(tesoro_requests_failed_total[5m])) > 0 for : 1m labels : severity : warning - alert : KapitanRevealRequestFailures annotations : message : kapitan_reveal_requests_failed_total has increased above 0 expr : sum by (job, namespace, service, env) (increase(kapitan_reveal_requests_failed_total[5m])) > 0 for : 1m labels : severity : warning","title":"PrometheusRules"},{"location":"kubernetes/#servicemonitor","text":"parameters : components : tesoro : service_monitors : endpoints : - interval : 15s path : / targetPort : 9095 produces the following resource apiVersion : monitoring.coreos.com/v1 kind : ServiceMonitor metadata : labels : name : tesoro-metrics name : tesoro-metrics namespace : tesoro spec : endpoints : - interval : 15s path : / targetPort : 9095 jobLabel : tesoro-metrics namespaceSelector : matchNames : - tesoro selector : matchLabels : name : tesoro","title":"ServiceMonitor"},{"location":"kubernetes/#role-role-bindings-and-cluster-role-cluster-role-bindings","text":"parameters : components : filebeat : # ServiceAccount service_account : enabled : true create : true # ROLE + Binding role : binding : subjects : - kind : ServiceAccount roleRef : apiGroup : rbac.authorization.k8s.io kind : Role rules : - apiGroups : - \"\" resources : - secrets verbs : - create - delete - apiGroups : - \"\" resources : - pods - pods/log verbs : - get - create - delete - list - watch - update produces the following resource --- apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : labels : name : filebeat name : filebeat namespace : filebeat rules : - apiGroups : - \"\" resources : - secrets verbs : - create - delete - apiGroups : - \"\" resources : - pods - pods/log verbs : - get - create - delete - list - watch - update --- apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : labels : name : filebeat name : filebeat namespace : filebeat roleRef : apiGroup : rbac.authorization.k8s.io kind : Role name : filebeat subjects : - kind : ServiceAccount name : filebeat --- apiVersion : v1 kind : ServiceAccount metadata : labels : name : filebeat name : filebeat namespace : filebeat","title":"Role, Role-Bindings and Cluster-Role, Cluster-Role-Bindings"},{"location":"kubernetes/#podsecuritypolicy","text":"The spec is relatively raw here, since its too diverse to be automated enough. Annotations and labels are merged from global and PSP ones. parameters : components : drone : pod_security_policy : annotations : xxx : yyy labels : yyy : zzz spec : privileged : false # Required to prevent escalations to root. allowPrivilegeEscalation : false # This is redundant with non-root + disallow privilege escalation, # but we can provide it for defense in depth. requiredDropCapabilities : - ALL # Allow core volume types. volumes : - \"configMap\" - \"emptyDir\" - \"projected\" - \"secret\" - \"downwardAPI\" - \"persistentVolumeClaim\" hostNetwork : false hostIPC : false hostPID : false runAsUser : rule : \"MustRunAsNonRoot\" seLinux : rule : \"RunAsAny\" supplementalGroups : rule : \"MustRunAs\" ranges : # Forbid adding the root group. - min : 1 max : 65535 fsGroup : rule : \"MustRunAs\" ranges : # Forbid adding the root group. - min : 1 max : 65535 readOnlyRootFilesystem : false produces the following resource --- apiVersion : policy/v1beta1 kind : PodSecurityPolicy metadata : annotations : manifests.kapicorp.com/generated : \"true\" xxx : yyy labels : app.kubernetes.io/component : go app.kubernetes.io/managed-by : kapitan app.kubernetes.io/part-of : drone app.kubernetes.io/version : \"1\" yyy : zzz name : drone namespace : drone spec : allowPrivilegeEscalation : false fsGroup : ranges : - max : 65535 min : 1 rule : MustRunAs hostIPC : false hostNetwork : false hostPID : false privileged : false readOnlyRootFilesystem : false requiredDropCapabilities : - ALL runAsUser : rule : MustRunAsNonRoot seLinux : rule : RunAsAny supplementalGroups : ranges : - max : 65535 min : 1 rule : MustRunAs volumes : - configMap - emptyDir - projected - secret - downwardAPI - persistentVolumeClaim","title":"PodSecurityPolicy"},{"location":"kubernetes/#defining-default-values-for-multiple-components","text":"Sometimes, when defining many components, you and up repeating many repeating configurations. With this generator, you can define defaults in 2 ways:","title":"Defining default values for multiple components"},{"location":"kubernetes/#global-generator-defaults","text":"The global defaults can be used to set defaults for every component being generated. As you can see, some defaults are already set: generators : manifest : default_config : type : deployment annotations : \"manifests.kapicorp.com/generated\" : true You do not have to change that class directly, as long as you add to the same inventory structure for another class. For instance, when we enable the features.tesoro class, we can see that we are adding the following yaml fragment: generators : manifest : default_config : globals : secrets : labels : tesoro.kapicorp.com : enabled Which has the effect to add the tesoro.kapicorp.com: enabled label to every generated configMap resource.","title":"Global Generator Defaults"},{"location":"kubernetes/#application-defaults","text":"You can also create application defaults, where an application is a class/profile that can be associated to multiple components. For instance, let's assume you have the following definition for an application class called microservices parameters : applications : microservices : component_defaults : replicas : 3 env : KAPITAN_APPLICATION : microservices Every component that belongs to that application class will receive the defaults for the application. To associate a component to an application, use the application directive. parameters : components : echo-server : application : microservices image : jmalloc/echo-server Compiling, kapitan will generate a deployment with image jmalloc/echo-server , 3 replicas, an annotation and an env variable. apiVersion : apps/v1 kind : Deployment metadata : annotations : manifests.kapicorp.com/generated : \"true\" labels : app : echo-server name : echo-server namespace : tutorial spec : replicas : 3 selector : matchLabels : app : echo-server strategy : rollingUpdate : maxSurge : 1 maxUnavailable : 1 type : RollingUpdate template : metadata : labels : app : echo-server spec : containers : - env : - name : KAPITAN_APPLICATION value : microservices image : jmalloc/echo-server imagePullPolicy : IfNotPresent name : echo-server restartPolicy : Always terminationGracePeriodSeconds : 30","title":"Application defaults"},{"location":"terraform/","text":"","title":"Terraform"},{"location":"tutorial/basecontent/","text":"BaseContent The BaseContent class extends the BaseModel class and provides methods to manipulate and work with content in various formats. BaseContent represents an object to be rendered : think of it as a (single item) JSON or YAML content. For instance, this could be the content of a BaseContent object: apiVersion : v1 kind : Service metadata : name : shark namespace : ocean spec : ports : - name : shark port : 8080 protocol : TCP targetPort : 8080 selector : app : shark sessionAffinity : None type : ClusterIP Attributes content_type Type : ContentType (default is ContentType.YAML ) Description : Defines the type of content (e.g., YAML). filename Type : str (default is \"output\") Description : The name of the output file. Methods body(self) This is an abstract method intended to be overridden by derived classes. Defines the body content. from_baseobj(cls, baseobj: BaseObj) -> BaseContent Class Method Initializes a BaseContent using a BaseObj . Parameters : baseobj : An instance of BaseObj . Returns : A new BaseContent instance. from_yaml(cls, file_path: str) -> List[BaseContent] Class Method Creates a list of BaseContent instances from a YAML file. Parameters : file_path : Path to the YAML file. Returns : List of BaseContent instances. from_dict(cls, dict_value: dict) -> BaseContent Class Method Creates a BaseContent instance from a dictionary. Parameters : dict_value : Dictionary to initialize from. Returns : A new BaseContent instance. parse(self, content: Dict) Parses content into the BaseContent instance. Parameters : content : Dictionary to parse. findpath(obj, path: str) Static Method Finds a nested attribute using dot notation. Parameters : obj : Object to search within. path : Dot notation path of the attribute. Returns : Value found at the specified path. mutate(self, mutations: List) Mutates the content based on provided mutations. Parameters : mutations : List of mutation rules. match(self, match_conditions: dict) -> bool Matches the content against provided conditions. Parameters : match_conditions : Dictionary of match conditions. Returns : Boolean indicating match success. patch(self, patch: dict) Applies a patch to the content. Parameters : patch : Dictionary representing the patch to be applied. BaseStore class The BaseStore class extends the BaseModel class and provides methods to manipulate a collection of BaseContent objects This is the class that will eventually be returned back to Kapitan from Kadet. Attributes content_list Type : List of BaseContent Description : Contains the list of BaseContent objects stored. Methods from_yaml_file(cls, file_path: str) -> BaseStore Class Method Loads a BaseStore instance from a YAML file. Parameters : file_path : Path to the YAML file. Returns : A new BaseStore instance populated with BaseContent objects from the YAML file. add(self, object: Any) Adds an object or list of objects to the store. Parameters : object : Object to add. Can be of type BaseContent , BaseStore , BaseObj , or list. add_list(self, contents: List[BaseContent]) Adds a list of BaseContent objects to the store. Parameters : contents : List of BaseContent objects. import_from_helm_chart(self, **kwargs) Imports BaseContent objects from a Helm chart. Parameters : **kwargs : Keyword arguments for the HelmChart object. apply_patch(self, patch: Dict) Applies a patch to every BaseContent in the store. Parameters : patch : Dictionary representing the patch to apply. process_mutations(self, mutations: Dict) Processes mutations on each BaseContent in the store. Parameters : mutations : Dictionary of mutations to process. get_content_list(self) -> List[BaseContent] Returns the list of BaseContent objects stored in the BaseStore . Returns : List of BaseContent objects. dump(self, output_filename: Optional[str] = None, already_processed: Optional[bool] = False) -> Any Dumps the BaseStore contents. Parameters : output_filename : Optional output filename. already_processed : Indicates if the content was processed before. Returns : A list or dictionary of dumped contents. Certainly! Here's the documentation markup for the BaseGenerator class: BaseGenerator Class Represents a base generator for handling generators functions. Initialization BaseGenerator(inventory: Dict, store: BaseStore = None, defaults_path: str = None) Parameters : inventory (Dict): The main content inventory. store (BaseStore, optional): The storage for generated content. Defaults to a new BaseStore instance. defaults_path (str, optional): Path to the default settings for the generator. Attributes inventory Type : Dict Description : The main content inventory. global_inventory Type : Function result Description : The global content inventory retrieved from inventory_global() . generator_defaults Type : Variable Type (based on the result of findpath ) Description : Defaults used by the generator, retrieved from the main inventory. store Type : BaseStore Description : The storage for generated content. Methods expand_and_run(self, func, params, inventory=None) Expands provided configurations and runs the specified function on them. Parameters : func : The function to run on each configuration. params : Parameters to guide the expansion. inventory (optional): The inventory to use. Defaults to the object's main inventory. generate(self) -> BaseStore Executes registered generators based on their activation paths and global flags. Returns : The updated BaseStore containing the generated content. Exceptions Raised CompileError Raised when neither 'path' nor 'activation_property' is provided in expand_and_run .","title":"BaseContent"},{"location":"tutorial/basecontent/#basecontent","text":"The BaseContent class extends the BaseModel class and provides methods to manipulate and work with content in various formats. BaseContent represents an object to be rendered : think of it as a (single item) JSON or YAML content. For instance, this could be the content of a BaseContent object: apiVersion : v1 kind : Service metadata : name : shark namespace : ocean spec : ports : - name : shark port : 8080 protocol : TCP targetPort : 8080 selector : app : shark sessionAffinity : None type : ClusterIP","title":"BaseContent"},{"location":"tutorial/basecontent/#attributes","text":"","title":"Attributes"},{"location":"tutorial/basecontent/#content_type","text":"Type : ContentType (default is ContentType.YAML ) Description : Defines the type of content (e.g., YAML).","title":"content_type"},{"location":"tutorial/basecontent/#filename","text":"Type : str (default is \"output\") Description : The name of the output file.","title":"filename"},{"location":"tutorial/basecontent/#methods","text":"","title":"Methods"},{"location":"tutorial/basecontent/#bodyself","text":"This is an abstract method intended to be overridden by derived classes. Defines the body content.","title":"body(self)"},{"location":"tutorial/basecontent/#from_baseobjcls-baseobj-baseobj-basecontent","text":"Class Method Initializes a BaseContent using a BaseObj . Parameters : baseobj : An instance of BaseObj . Returns : A new BaseContent instance.","title":"from_baseobj(cls, baseobj: BaseObj) -&gt; BaseContent"},{"location":"tutorial/basecontent/#from_yamlcls-file_path-str-listbasecontent","text":"Class Method Creates a list of BaseContent instances from a YAML file. Parameters : file_path : Path to the YAML file. Returns : List of BaseContent instances.","title":"from_yaml(cls, file_path: str) -&gt; List[BaseContent]"},{"location":"tutorial/basecontent/#from_dictcls-dict_value-dict-basecontent","text":"Class Method Creates a BaseContent instance from a dictionary. Parameters : dict_value : Dictionary to initialize from. Returns : A new BaseContent instance.","title":"from_dict(cls, dict_value: dict) -&gt; BaseContent"},{"location":"tutorial/basecontent/#parseself-content-dict","text":"Parses content into the BaseContent instance. Parameters : content : Dictionary to parse.","title":"parse(self, content: Dict)"},{"location":"tutorial/basecontent/#findpathobj-path-str","text":"Static Method Finds a nested attribute using dot notation. Parameters : obj : Object to search within. path : Dot notation path of the attribute. Returns : Value found at the specified path.","title":"findpath(obj, path: str)"},{"location":"tutorial/basecontent/#mutateself-mutations-list","text":"Mutates the content based on provided mutations. Parameters : mutations : List of mutation rules.","title":"mutate(self, mutations: List)"},{"location":"tutorial/basecontent/#matchself-match_conditions-dict-bool","text":"Matches the content against provided conditions. Parameters : match_conditions : Dictionary of match conditions. Returns : Boolean indicating match success.","title":"match(self, match_conditions: dict) -&gt; bool"},{"location":"tutorial/basecontent/#patchself-patch-dict","text":"Applies a patch to the content. Parameters : patch : Dictionary representing the patch to be applied.","title":"patch(self, patch: dict)"},{"location":"tutorial/basecontent/#basestore-class","text":"The BaseStore class extends the BaseModel class and provides methods to manipulate a collection of BaseContent objects This is the class that will eventually be returned back to Kapitan from Kadet.","title":"BaseStore class"},{"location":"tutorial/basecontent/#attributes_1","text":"","title":"Attributes"},{"location":"tutorial/basecontent/#content_list","text":"Type : List of BaseContent Description : Contains the list of BaseContent objects stored.","title":"content_list"},{"location":"tutorial/basecontent/#methods_1","text":"","title":"Methods"},{"location":"tutorial/basecontent/#from_yaml_filecls-file_path-str-basestore","text":"Class Method Loads a BaseStore instance from a YAML file. Parameters : file_path : Path to the YAML file. Returns : A new BaseStore instance populated with BaseContent objects from the YAML file.","title":"from_yaml_file(cls, file_path: str) -&gt; BaseStore"},{"location":"tutorial/basecontent/#addself-object-any","text":"Adds an object or list of objects to the store. Parameters : object : Object to add. Can be of type BaseContent , BaseStore , BaseObj , or list.","title":"add(self, object: Any)"},{"location":"tutorial/basecontent/#add_listself-contents-listbasecontent","text":"Adds a list of BaseContent objects to the store. Parameters : contents : List of BaseContent objects.","title":"add_list(self, contents: List[BaseContent])"},{"location":"tutorial/basecontent/#import_from_helm_chartself-kwargs","text":"Imports BaseContent objects from a Helm chart. Parameters : **kwargs : Keyword arguments for the HelmChart object.","title":"import_from_helm_chart(self, **kwargs)"},{"location":"tutorial/basecontent/#apply_patchself-patch-dict","text":"Applies a patch to every BaseContent in the store. Parameters : patch : Dictionary representing the patch to apply.","title":"apply_patch(self, patch: Dict)"},{"location":"tutorial/basecontent/#process_mutationsself-mutations-dict","text":"Processes mutations on each BaseContent in the store. Parameters : mutations : Dictionary of mutations to process.","title":"process_mutations(self, mutations: Dict)"},{"location":"tutorial/basecontent/#get_content_listself-listbasecontent","text":"Returns the list of BaseContent objects stored in the BaseStore . Returns : List of BaseContent objects.","title":"get_content_list(self) -&gt; List[BaseContent]"},{"location":"tutorial/basecontent/#dumpself-output_filename-optionalstr-none-already_processed-optionalbool-false-any","text":"Dumps the BaseStore contents. Parameters : output_filename : Optional output filename. already_processed : Indicates if the content was processed before. Returns : A list or dictionary of dumped contents. Certainly! Here's the documentation markup for the BaseGenerator class:","title":"dump(self, output_filename: Optional[str] = None, already_processed: Optional[bool] = False) -&gt; Any"},{"location":"tutorial/basecontent/#basegenerator-class","text":"Represents a base generator for handling generators functions.","title":"BaseGenerator Class"},{"location":"tutorial/basecontent/#initialization","text":"BaseGenerator(inventory: Dict, store: BaseStore = None, defaults_path: str = None) Parameters : inventory (Dict): The main content inventory. store (BaseStore, optional): The storage for generated content. Defaults to a new BaseStore instance. defaults_path (str, optional): Path to the default settings for the generator.","title":"Initialization"},{"location":"tutorial/basecontent/#attributes_2","text":"","title":"Attributes"},{"location":"tutorial/basecontent/#inventory","text":"Type : Dict Description : The main content inventory.","title":"inventory"},{"location":"tutorial/basecontent/#global_inventory","text":"Type : Function result Description : The global content inventory retrieved from inventory_global() .","title":"global_inventory"},{"location":"tutorial/basecontent/#generator_defaults","text":"Type : Variable Type (based on the result of findpath ) Description : Defaults used by the generator, retrieved from the main inventory.","title":"generator_defaults"},{"location":"tutorial/basecontent/#store","text":"Type : BaseStore Description : The storage for generated content.","title":"store"},{"location":"tutorial/basecontent/#methods_2","text":"","title":"Methods"},{"location":"tutorial/basecontent/#expand_and_runself-func-params-inventorynone","text":"Expands provided configurations and runs the specified function on them. Parameters : func : The function to run on each configuration. params : Parameters to guide the expansion. inventory (optional): The inventory to use. Defaults to the object's main inventory.","title":"expand_and_run(self, func, params, inventory=None)"},{"location":"tutorial/basecontent/#generateself-basestore","text":"Executes registered generators based on their activation paths and global flags. Returns : The updated BaseStore containing the generated content.","title":"generate(self) -&gt; BaseStore"},{"location":"tutorial/basecontent/#exceptions-raised","text":"","title":"Exceptions Raised"},{"location":"tutorial/basecontent/#compileerror","text":"Raised when neither 'path' nor 'activation_property' is provided in expand_and_run .","title":"CompileError"},{"location":"tutorial/basegenerator/","text":"BaseGenerator Represents a base generator for handling generators functions. Initialization BaseGenerator(inventory: Dict, store: BaseStore = None, defaults_path: str = None) Parameters : inventory (Dict): The main content inventory. store (BaseStore, optional): The storage for generated content. Defaults to a new BaseStore instance. defaults_path (str, optional): Path to the default settings for the generator. Attributes inventory Type : Dict Description : The main content inventory. global_inventory Type : Function result Description : The global content inventory retrieved from inventory_global() . generator_defaults Type : Variable Type (based on the result of findpath ) Description : Defaults used by the generator, retrieved from the main inventory. store Type : BaseStore Description : The storage for generated content. Methods expand_and_run(self, func, params, inventory=None) Expands provided configurations and runs the specified function on them. Parameters : func : The function to run on each configuration. params : Parameters to guide the expansion. inventory (optional): The inventory to use. Defaults to the object's main inventory. generate(self) -> BaseStore Executes registered generators based on their activation paths and global flags. Returns : The updated BaseStore containing the generated content. Exceptions Raised CompileError Raised when neither 'path' nor 'activation_property' is provided in expand_and_run .","title":"BaseGenerator"},{"location":"tutorial/basegenerator/#basegenerator","text":"Represents a base generator for handling generators functions.","title":"BaseGenerator"},{"location":"tutorial/basegenerator/#initialization","text":"BaseGenerator(inventory: Dict, store: BaseStore = None, defaults_path: str = None) Parameters : inventory (Dict): The main content inventory. store (BaseStore, optional): The storage for generated content. Defaults to a new BaseStore instance. defaults_path (str, optional): Path to the default settings for the generator.","title":"Initialization"},{"location":"tutorial/basegenerator/#attributes","text":"","title":"Attributes"},{"location":"tutorial/basegenerator/#inventory","text":"Type : Dict Description : The main content inventory.","title":"inventory"},{"location":"tutorial/basegenerator/#global_inventory","text":"Type : Function result Description : The global content inventory retrieved from inventory_global() .","title":"global_inventory"},{"location":"tutorial/basegenerator/#generator_defaults","text":"Type : Variable Type (based on the result of findpath ) Description : Defaults used by the generator, retrieved from the main inventory.","title":"generator_defaults"},{"location":"tutorial/basegenerator/#store","text":"Type : BaseStore Description : The storage for generated content.","title":"store"},{"location":"tutorial/basegenerator/#methods","text":"","title":"Methods"},{"location":"tutorial/basegenerator/#expand_and_runself-func-params-inventorynone","text":"Expands provided configurations and runs the specified function on them. Parameters : func : The function to run on each configuration. params : Parameters to guide the expansion. inventory (optional): The inventory to use. Defaults to the object's main inventory.","title":"expand_and_run(self, func, params, inventory=None)"},{"location":"tutorial/basegenerator/#generateself-basestore","text":"Executes registered generators based on their activation paths and global flags. Returns : The updated BaseStore containing the generated content.","title":"generate(self) -&gt; BaseStore"},{"location":"tutorial/basegenerator/#exceptions-raised","text":"","title":"Exceptions Raised"},{"location":"tutorial/basegenerator/#compileerror","text":"Raised when neither 'path' nor 'activation_property' is provided in expand_and_run .","title":"CompileError"},{"location":"tutorial/basestore/","text":"BaseStore The BaseStore class extends the BaseModel class and provides methods to manipulate a collection of BaseContent objects This is the class that will eventually be returned back to Kapitan from Kadet. Attributes content_list Type : List of BaseContent Description : Contains the list of BaseContent objects stored. Methods from_yaml_file(cls, file_path: str) -> BaseStore Class Method Loads a BaseStore instance from a YAML file. Parameters : file_path : Path to the YAML file. Returns : A new BaseStore instance populated with BaseContent objects from the YAML file. add(self, object: Any) Adds an object or list of objects to the store. Parameters : object : Object to add. Can be of type BaseContent , BaseStore , BaseObj , or list. add_list(self, contents: List[BaseContent]) Adds a list of BaseContent objects to the store. Parameters : contents : List of BaseContent objects. import_from_helm_chart(self, **kwargs) Imports BaseContent objects from a Helm chart. Parameters : **kwargs : Keyword arguments for the HelmChart object. apply_patch(self, patch: Dict) Applies a patch to every BaseContent in the store. Parameters : patch : Dictionary representing the patch to apply. process_mutations(self, mutations: Dict) Processes mutations on each BaseContent in the store. Parameters : mutations : Dictionary of mutations to process. get_content_list(self) -> List[BaseContent] Returns the list of BaseContent objects stored in the BaseStore . Returns : List of BaseContent objects. dump(self, output_filename: Optional[str] = None, already_processed: Optional[bool] = False) -> Any Dumps the BaseStore contents. Parameters : output_filename : Optional output filename. already_processed : Indicates if the content was processed before. Returns : A list or dictionary of dumped contents. Certainly! Here's the documentation markup for the BaseGenerator class: BaseGenerator Class Represents a base generator for handling generators functions. Initialization BaseGenerator(inventory: Dict, store: BaseStore = None, defaults_path: str = None) Parameters : inventory (Dict): The main content inventory. store (BaseStore, optional): The storage for generated content. Defaults to a new BaseStore instance. defaults_path (str, optional): Path to the default settings for the generator. Attributes inventory Type : Dict Description : The main content inventory. global_inventory Type : Function result Description : The global content inventory retrieved from inventory_global() . generator_defaults Type : Variable Type (based on the result of findpath ) Description : Defaults used by the generator, retrieved from the main inventory. store Type : BaseStore Description : The storage for generated content. Methods expand_and_run(self, func, params, inventory=None) Expands provided configurations and runs the specified function on them. Parameters : func : The function to run on each configuration. params : Parameters to guide the expansion. inventory (optional): The inventory to use. Defaults to the object's main inventory. generate(self) -> BaseStore Executes registered generators based on their activation paths and global flags. Returns : The updated BaseStore containing the generated content. Exceptions Raised CompileError Raised when neither 'path' nor 'activation_property' is provided in expand_and_run .","title":"BaseStore"},{"location":"tutorial/basestore/#basestore","text":"The BaseStore class extends the BaseModel class and provides methods to manipulate a collection of BaseContent objects This is the class that will eventually be returned back to Kapitan from Kadet.","title":"BaseStore"},{"location":"tutorial/basestore/#attributes","text":"","title":"Attributes"},{"location":"tutorial/basestore/#content_list","text":"Type : List of BaseContent Description : Contains the list of BaseContent objects stored.","title":"content_list"},{"location":"tutorial/basestore/#methods","text":"","title":"Methods"},{"location":"tutorial/basestore/#from_yaml_filecls-file_path-str-basestore","text":"Class Method Loads a BaseStore instance from a YAML file. Parameters : file_path : Path to the YAML file. Returns : A new BaseStore instance populated with BaseContent objects from the YAML file.","title":"from_yaml_file(cls, file_path: str) -&gt; BaseStore"},{"location":"tutorial/basestore/#addself-object-any","text":"Adds an object or list of objects to the store. Parameters : object : Object to add. Can be of type BaseContent , BaseStore , BaseObj , or list.","title":"add(self, object: Any)"},{"location":"tutorial/basestore/#add_listself-contents-listbasecontent","text":"Adds a list of BaseContent objects to the store. Parameters : contents : List of BaseContent objects.","title":"add_list(self, contents: List[BaseContent])"},{"location":"tutorial/basestore/#import_from_helm_chartself-kwargs","text":"Imports BaseContent objects from a Helm chart. Parameters : **kwargs : Keyword arguments for the HelmChart object.","title":"import_from_helm_chart(self, **kwargs)"},{"location":"tutorial/basestore/#apply_patchself-patch-dict","text":"Applies a patch to every BaseContent in the store. Parameters : patch : Dictionary representing the patch to apply.","title":"apply_patch(self, patch: Dict)"},{"location":"tutorial/basestore/#process_mutationsself-mutations-dict","text":"Processes mutations on each BaseContent in the store. Parameters : mutations : Dictionary of mutations to process.","title":"process_mutations(self, mutations: Dict)"},{"location":"tutorial/basestore/#get_content_listself-listbasecontent","text":"Returns the list of BaseContent objects stored in the BaseStore . Returns : List of BaseContent objects.","title":"get_content_list(self) -&gt; List[BaseContent]"},{"location":"tutorial/basestore/#dumpself-output_filename-optionalstr-none-already_processed-optionalbool-false-any","text":"Dumps the BaseStore contents. Parameters : output_filename : Optional output filename. already_processed : Indicates if the content was processed before. Returns : A list or dictionary of dumped contents. Certainly! Here's the documentation markup for the BaseGenerator class:","title":"dump(self, output_filename: Optional[str] = None, already_processed: Optional[bool] = False) -&gt; Any"},{"location":"tutorial/basestore/#basegenerator-class","text":"Represents a base generator for handling generators functions.","title":"BaseGenerator Class"},{"location":"tutorial/basestore/#initialization","text":"BaseGenerator(inventory: Dict, store: BaseStore = None, defaults_path: str = None) Parameters : inventory (Dict): The main content inventory. store (BaseStore, optional): The storage for generated content. Defaults to a new BaseStore instance. defaults_path (str, optional): Path to the default settings for the generator.","title":"Initialization"},{"location":"tutorial/basestore/#attributes_1","text":"","title":"Attributes"},{"location":"tutorial/basestore/#inventory","text":"Type : Dict Description : The main content inventory.","title":"inventory"},{"location":"tutorial/basestore/#global_inventory","text":"Type : Function result Description : The global content inventory retrieved from inventory_global() .","title":"global_inventory"},{"location":"tutorial/basestore/#generator_defaults","text":"Type : Variable Type (based on the result of findpath ) Description : Defaults used by the generator, retrieved from the main inventory.","title":"generator_defaults"},{"location":"tutorial/basestore/#store","text":"Type : BaseStore Description : The storage for generated content.","title":"store"},{"location":"tutorial/basestore/#methods_1","text":"","title":"Methods"},{"location":"tutorial/basestore/#expand_and_runself-func-params-inventorynone","text":"Expands provided configurations and runs the specified function on them. Parameters : func : The function to run on each configuration. params : Parameters to guide the expansion. inventory (optional): The inventory to use. Defaults to the object's main inventory.","title":"expand_and_run(self, func, params, inventory=None)"},{"location":"tutorial/basestore/#generateself-basestore","text":"Executes registered generators based on their activation paths and global flags. Returns : The updated BaseStore containing the generated content.","title":"generate(self) -&gt; BaseStore"},{"location":"tutorial/basestore/#exceptions-raised","text":"","title":"Exceptions Raised"},{"location":"tutorial/basestore/#compileerror","text":"Raised when neither 'path' nor 'activation_property' is provided in expand_and_run .","title":"CompileError"},{"location":"tutorial/concepts/","text":"Concepts Understanding Kapitan Generators What are Kapitan Generators? Kapitan generators empower you to utilize the Kapitan inventory's configuration to formulate resources and objects. Instead of relying on jsonnet or kadet directly, envision generators as bespoke templates. They act akin to a personalized Domain Specific Language (DSL) for the exact resource or file you're designing. Who is this Guide Aimed At? Should you aspire to either augment existing generators or architect your own, this guide caters to you. Be aware, familiarity with Kapitan is a prerequisite; thus, basic Kapitan tenets won't be discussed. Introducing klibgen klibgen is an innovative library crafted to streamline creating new generators. Opting for klibgen endows you with several inherent features to elevate your experience: Decorator Utility : Swiftly morph your class into a generator. Automatic Context Provision : An innate context is endowed to your class. Defaults Integration : Incorporate default configurations effortlessly. Post-Creation Modifications : Amend objects subsequent to their creation. Diverse Generator Support : Be it target-centric or universal generators, klibgen has your back. Contextual Elements in Kapitan Generators Upon Kapitan activating your generator classes, an array of fields are accessible: Variable Description self.id Unique ID tied to the generator configuration. self.name Name stipulated in the config or the designated ID. self.config Config content of the generator with patches incorporated. self.inventory Specific inventory for the stipulated target. self.global_inventory Kapitan-wide accessible inventory. self.defaults Preset configurations for this specific generator. self.target Designation of the ongoing target. self.patches_applied Array of patches amalgamated into the foundational config. self.original_config The pristine, unaltered configuration.","title":"Concepts"},{"location":"tutorial/concepts/#concepts","text":"","title":"Concepts"},{"location":"tutorial/concepts/#understanding-kapitan-generators","text":"","title":"Understanding Kapitan Generators"},{"location":"tutorial/concepts/#what-are-kapitan-generators","text":"Kapitan generators empower you to utilize the Kapitan inventory's configuration to formulate resources and objects. Instead of relying on jsonnet or kadet directly, envision generators as bespoke templates. They act akin to a personalized Domain Specific Language (DSL) for the exact resource or file you're designing.","title":"What are Kapitan Generators?"},{"location":"tutorial/concepts/#who-is-this-guide-aimed-at","text":"Should you aspire to either augment existing generators or architect your own, this guide caters to you. Be aware, familiarity with Kapitan is a prerequisite; thus, basic Kapitan tenets won't be discussed.","title":"Who is this Guide Aimed At?"},{"location":"tutorial/concepts/#introducing-klibgen","text":"klibgen is an innovative library crafted to streamline creating new generators. Opting for klibgen endows you with several inherent features to elevate your experience: Decorator Utility : Swiftly morph your class into a generator. Automatic Context Provision : An innate context is endowed to your class. Defaults Integration : Incorporate default configurations effortlessly. Post-Creation Modifications : Amend objects subsequent to their creation. Diverse Generator Support : Be it target-centric or universal generators, klibgen has your back.","title":"Introducing klibgen"},{"location":"tutorial/concepts/#contextual-elements-in-kapitan-generators","text":"Upon Kapitan activating your generator classes, an array of fields are accessible: Variable Description self.id Unique ID tied to the generator configuration. self.name Name stipulated in the config or the designated ID. self.config Config content of the generator with patches incorporated. self.inventory Specific inventory for the stipulated target. self.global_inventory Kapitan-wide accessible inventory. self.defaults Preset configurations for this specific generator. self.target Designation of the ongoing target. self.patches_applied Array of patches amalgamated into the foundational config. self.original_config The pristine, unaltered configuration.","title":"Contextual Elements in Kapitan Generators"},{"location":"tutorial/faq/","text":"FAQ Why use BaseContent and BaseStore ? These classes from kgenlib make object rendering explicit and add more functionalities. Can multiple generator classes register for the same path? Yes, this allows for flexibility. For instance, you can have both AWS and GCP terraform generators using the same configuration.","title":"FAQ"},{"location":"tutorial/faq/#faq","text":"","title":"FAQ"},{"location":"tutorial/faq/#why-use-basecontent-and-basestore","text":"These classes from kgenlib make object rendering explicit and add more functionalities.","title":"Why use BaseContent and BaseStore?"},{"location":"tutorial/faq/#can-multiple-generator-classes-register-for-the-same-path","text":"Yes, this allows for flexibility. For instance, you can have both AWS and GCP terraform generators using the same configuration.","title":"Can multiple generator classes register for the same path?"},{"location":"tutorial/global_generators/","text":"Global Generators Global Generators in Kapitan Introduction to Global Generators Unlike target generators, which derive their configurations from a specific target inventory, global generators cater to situations where configurations span multiple 'source' targets. Yet, there's a requirement for their outputs to funnel into a singular 'destination' target. Use Case Example Consider generating ArgoCD Applications. While the manifest files need generation into the \"apps_of_apps\" target, it's ideal for the configurations to reside alongside the source target. Crafting a Global Generator To initiate a global generator, employ the Python decorator below: @kgenlib . register_generator ( path = \"generators.argocd.applications\" , global_generator = True , activation_path = \"argocd.app_of_apps\" , ) class GenArgoCDApplication ( kgenlib . BaseStore ): ... In the above snippet: global_generator : Ensures configurations are sourced from all clusters, not just one. activation_path : Informs Kapitan to generate manifests within the target housing that unique path.","title":"Global Generators"},{"location":"tutorial/global_generators/#global-generators","text":"","title":"Global Generators"},{"location":"tutorial/global_generators/#global-generators-in-kapitan","text":"","title":"Global Generators in Kapitan"},{"location":"tutorial/global_generators/#introduction-to-global-generators","text":"Unlike target generators, which derive their configurations from a specific target inventory, global generators cater to situations where configurations span multiple 'source' targets. Yet, there's a requirement for their outputs to funnel into a singular 'destination' target.","title":"Introduction to Global Generators"},{"location":"tutorial/global_generators/#use-case-example","text":"Consider generating ArgoCD Applications. While the manifest files need generation into the \"apps_of_apps\" target, it's ideal for the configurations to reside alongside the source target.","title":"Use Case Example"},{"location":"tutorial/global_generators/#crafting-a-global-generator","text":"To initiate a global generator, employ the Python decorator below: @kgenlib . register_generator ( path = \"generators.argocd.applications\" , global_generator = True , activation_path = \"argocd.app_of_apps\" , ) class GenArgoCDApplication ( kgenlib . BaseStore ): ... In the above snippet: global_generator : Ensures configurations are sourced from all clusters, not just one. activation_path : Informs Kapitan to generate manifests within the target housing that unique path.","title":"Crafting a Global Generator"},{"location":"tutorial/mutations/","text":"Mutations Mutations in kgenlib Introduction to Mutations In kgenlib , \"Mutations\" are tools that let you modify the objects generated based on certain criteria. They provide more granular control over the generation process, allowing you to dynamically adjust outputs based on predefined rules. Example: Mutating Helm Chart Manifests Given a configuration producing manifests from a helm chart: charts : keel : chart_dir : ${keel:chart_dir} helm_params : namespace : ${keel:namespace} name : ${keel:chart_name} output_file : ${keel:chart_name}.yml helm_values : ${keel:helm_values} You can set up the following mutations to adjust the objects the Helm chart generates: mutations : bundle : - conditions : kind : [ CustomResourceDefinition ] filename : keel-crds - conditions : kind : [ '*' ] filename : keel-bundle delete : - conditions : kind : [ ConfigMap ] metadata.name : [ \"keel-config\" ] patch : - conditions : kind : [ CustomResourceDefinition ] patch : metadata : annotations : argocd.argoproj.io/sync-options : SkipDryRunOnMissingResource=true,Replace=true Mutation Types Bundle : Dictates where objects are stored. filename : Redefines the file where objects matching conditions are placed. Patch : Add or remove patches to objects that match given conditions. Delete : Removes objects that fit the criteria. Advanced Bundle Use The filename parameter in the bundle mutation is an \"f-format\" string, accepting the resource content. This means configurations like: mutations : bundle : - conditions : kind : [ '*' ] filename : \"{content.metadata.namespace}/{content.metadata.name} Can dynamically relocate generated files into subdirectories based on their namespace, adding another layer of organization.","title":"Mutations"},{"location":"tutorial/mutations/#mutations","text":"","title":"Mutations"},{"location":"tutorial/mutations/#mutations-in-kgenlib","text":"","title":"Mutations in kgenlib"},{"location":"tutorial/mutations/#introduction-to-mutations","text":"In kgenlib , \"Mutations\" are tools that let you modify the objects generated based on certain criteria. They provide more granular control over the generation process, allowing you to dynamically adjust outputs based on predefined rules.","title":"Introduction to Mutations"},{"location":"tutorial/mutations/#example-mutating-helm-chart-manifests","text":"Given a configuration producing manifests from a helm chart: charts : keel : chart_dir : ${keel:chart_dir} helm_params : namespace : ${keel:namespace} name : ${keel:chart_name} output_file : ${keel:chart_name}.yml helm_values : ${keel:helm_values} You can set up the following mutations to adjust the objects the Helm chart generates: mutations : bundle : - conditions : kind : [ CustomResourceDefinition ] filename : keel-crds - conditions : kind : [ '*' ] filename : keel-bundle delete : - conditions : kind : [ ConfigMap ] metadata.name : [ \"keel-config\" ] patch : - conditions : kind : [ CustomResourceDefinition ] patch : metadata : annotations : argocd.argoproj.io/sync-options : SkipDryRunOnMissingResource=true,Replace=true","title":"Example: Mutating Helm Chart Manifests"},{"location":"tutorial/mutations/#mutation-types","text":"Bundle : Dictates where objects are stored. filename : Redefines the file where objects matching conditions are placed. Patch : Add or remove patches to objects that match given conditions. Delete : Removes objects that fit the criteria.","title":"Mutation Types"},{"location":"tutorial/mutations/#advanced-bundle-use","text":"The filename parameter in the bundle mutation is an \"f-format\" string, accepting the resource content. This means configurations like: mutations : bundle : - conditions : kind : [ '*' ] filename : \"{content.metadata.namespace}/{content.metadata.name} Can dynamically relocate generated files into subdirectories based on their namespace, adding another layer of organization.","title":"Advanced Bundle Use"},{"location":"tutorial/patching/","text":"Patching Configuration Patching in Kapitan with kgenlib Automatic Configuration Patching kgenlib introduces a seamless way to auto-merge your configuration with default values using the apply_patches decorator attribute. This is especially handy when you want certain base configurations to be consistently present, and then layer on more specific configurations as needed. Example: Merging with Defaults The following Python decorator showcases how you can employ the apply_patches feature: @kgenlib . register_generator ( path = \"kapicorp.simple_fish_generator\" , apply_patches = [ \"generators.defaults.simple_fish_generator\" ], ) In the above illustration: The apply_patches attribute is supplied with a list that denotes the path to the default configurations. The defined generator, when invoked, would incorporate configurations from generators.defaults.simple_fish_generator seamlessly into its own. Advanced Features Chaining Multiple Patches : If there's a need to merge configurations from multiple sources, just extend the list provided to apply_patches . Variable Interpolation : For those situations where you require custom configurations, kgenlib facilitates variable interpolation. This means you can use variables in your configuration and have them be replaced with actual values during the generation process.","title":"Patching"},{"location":"tutorial/patching/#patching","text":"","title":"Patching"},{"location":"tutorial/patching/#configuration-patching-in-kapitan-with-kgenlib","text":"","title":"Configuration Patching in Kapitan with kgenlib"},{"location":"tutorial/patching/#automatic-configuration-patching","text":"kgenlib introduces a seamless way to auto-merge your configuration with default values using the apply_patches decorator attribute. This is especially handy when you want certain base configurations to be consistently present, and then layer on more specific configurations as needed.","title":"Automatic Configuration Patching"},{"location":"tutorial/patching/#example-merging-with-defaults","text":"The following Python decorator showcases how you can employ the apply_patches feature: @kgenlib . register_generator ( path = \"kapicorp.simple_fish_generator\" , apply_patches = [ \"generators.defaults.simple_fish_generator\" ], ) In the above illustration: The apply_patches attribute is supplied with a list that denotes the path to the default configurations. The defined generator, when invoked, would incorporate configurations from generators.defaults.simple_fish_generator seamlessly into its own.","title":"Example: Merging with Defaults"},{"location":"tutorial/patching/#advanced-features","text":"Chaining Multiple Patches : If there's a need to merge configurations from multiple sources, just extend the list provided to apply_patches . Variable Interpolation : For those situations where you require custom configurations, kgenlib facilitates variable interpolation. This means you can use variables in your configuration and have them be replaced with actual values during the generation process.","title":"Advanced Features"},{"location":"tutorial/setup/","text":"Setup Developing new generators is straightforward with the kgenlib library. In this tutorial, you'll learn to create a generator class for the Kubernetes CRD object, the Fish CRD . Setup the Environment Clone the Kapitan Reference repository: git clone git@github.com:kapicorp/kapitan-reference.git cd kapitan-reference Verify the setup by compiling: ./kapitan compile Configuration Kapitan should iterate over the following configuration to produce Kubernetes resources: parameters : kapicorp : simple_fish_generator : cod : family : Gadidae blue_shark : name : blue-shark family : Carcharhinidae Note : This configuration is available in targets/examples/tutorial.yml .","title":"Setup"},{"location":"tutorial/setup/#setup","text":"Developing new generators is straightforward with the kgenlib library. In this tutorial, you'll learn to create a generator class for the Kubernetes CRD object, the Fish CRD .","title":"Setup"},{"location":"tutorial/setup/#setup-the-environment","text":"Clone the Kapitan Reference repository: git clone git@github.com:kapicorp/kapitan-reference.git cd kapitan-reference Verify the setup by compiling: ./kapitan compile","title":"Setup the Environment"},{"location":"tutorial/setup/#configuration","text":"Kapitan should iterate over the following configuration to produce Kubernetes resources: parameters : kapicorp : simple_fish_generator : cod : family : Gadidae blue_shark : name : blue-shark family : Carcharhinidae Note : This configuration is available in targets/examples/tutorial.yml .","title":"Configuration"},{"location":"tutorial/target_generators/","text":"Target generators Target Generators in Kapitan What is a Target Generator? A target generator is a specialized Generator class that focuses on processing the configuration of a single target. To give an illustrative example, if one sets up the configuration for a target named nginx as follows: parameters : components : nginx : image : nginx ... The expected behavior would be for the kubernetes generator to churn out manifests into the compiled/nginx/manifest output target. What's noteworthy here is that the nature of resources generated\u2014like ConfigMap, Secret, Service\u2014depends on the nginx component's configuration. Crafting a Target Generator To lay the foundation for a target generator, employ the provided Python decorator: @kgenlib . register_generator ( path = \"components\" , ... ) class Components ( kgenlib . BaseStore ): This configuration indicates that the generator will spring into action for configurations housed under the parameters.components inventory segment, but only for that specific target.","title":"Target generators"},{"location":"tutorial/target_generators/#target-generators","text":"","title":"Target generators"},{"location":"tutorial/target_generators/#target-generators-in-kapitan","text":"","title":"Target Generators in Kapitan"},{"location":"tutorial/target_generators/#what-is-a-target-generator","text":"A target generator is a specialized Generator class that focuses on processing the configuration of a single target. To give an illustrative example, if one sets up the configuration for a target named nginx as follows: parameters : components : nginx : image : nginx ... The expected behavior would be for the kubernetes generator to churn out manifests into the compiled/nginx/manifest output target. What's noteworthy here is that the nature of resources generated\u2014like ConfigMap, Secret, Service\u2014depends on the nginx component's configuration.","title":"What is a Target Generator?"},{"location":"tutorial/target_generators/#crafting-a-target-generator","text":"To lay the foundation for a target generator, employ the provided Python decorator: @kgenlib . register_generator ( path = \"components\" , ... ) class Components ( kgenlib . BaseStore ): This configuration indicates that the generator will spring into action for configurations housed under the parameters.components inventory segment, but only for that specific target.","title":"Crafting a Target Generator"},{"location":"tutorial/tutorial/","text":"Example code GenSimpleFishGenerator Create a new file named fish.py in the directory system/generators/kubernetes/ and add the following content: import logging logger = logging . getLogger ( __name__ ) from .common import KubernetesResource , kgenlib ... Register the generator classes with Kapitan using the @kgenlib.register_generator annotation. Here's an example: @kgenlib . register_generator ( path = \"kapicorp.simple_fish_generator\" , ) class GenSimpleFishGenerator ( KubernetesResource ): api_version = \"fish/v1\" kind = \"Fish\" def body ( self ): super () . body () logger . info ( f \"Running { __name__ } with id = { self . id } and config = { self . config } \" ) When Kapitan runs, it matches dictionary items with the specified path, then invokes your GenSimpleFishGenerator class. Execute Kapitan to see the generated output: ./kapitan compile -t tutorial Inspect the generated files: git status compiled Enhancing the Resource Utilize the self.config variable to enrich the fish object: ... @kgenlib . register_generator ( path = \"kapicorp.simple_fish_generator\" , ) ... self . root . spec . family = self . config . get ( \"family\" , None ) This addition will populate the family attribute of the fish under the spec field.","title":"Example code"},{"location":"tutorial/tutorial/#example-code","text":"","title":"Example code"},{"location":"tutorial/tutorial/#gensimplefishgenerator","text":"Create a new file named fish.py in the directory system/generators/kubernetes/ and add the following content: import logging logger = logging . getLogger ( __name__ ) from .common import KubernetesResource , kgenlib ... Register the generator classes with Kapitan using the @kgenlib.register_generator annotation. Here's an example: @kgenlib . register_generator ( path = \"kapicorp.simple_fish_generator\" , ) class GenSimpleFishGenerator ( KubernetesResource ): api_version = \"fish/v1\" kind = \"Fish\" def body ( self ): super () . body () logger . info ( f \"Running { __name__ } with id = { self . id } and config = { self . config } \" ) When Kapitan runs, it matches dictionary items with the specified path, then invokes your GenSimpleFishGenerator class. Execute Kapitan to see the generated output: ./kapitan compile -t tutorial Inspect the generated files: git status compiled","title":"GenSimpleFishGenerator"},{"location":"tutorial/tutorial/#enhancing-the-resource","text":"Utilize the self.config variable to enrich the fish object: ... @kgenlib . register_generator ( path = \"kapicorp.simple_fish_generator\" , ) ... self . root . spec . family = self . config . get ( \"family\" , None ) This addition will populate the family attribute of the fish under the spec field.","title":"Enhancing the Resource"}]}